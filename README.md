# java_13day_class_4
클래스 구조

>클래스의 구조:
>클래스 정의 형식(모든 대괄호는 생략이 가능)
무조건 외우고 시작.
ㅡ[클래스명.java]ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
package 패키지명;
import 수입클래스패키지명.수입클래스명;
  [public] [abstract/final] class 클래스명 {
 
public/protected/default/private [static] [final] 기본자료형/클래스명/인터페이스명  속성변수명 [=데이터];
 
public/protected/default/private  생성자명 ( [자료형 매개변수, ~] ) {
 
      실행구문;
 
  }
 
public/protected/default/private [static] [synchronized] [final / abstract] 기본형/클래스명/인터페이스명/void 
    메소드명( [자료형 매개변수, ~]
    ){
      실행구문;
   }
}
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
 
>1. package 패키지명;

자기가 소속된 것
>2. import 수입클래스패키지명.수입클래스명;

타클래스를 가져오려면 
(외부손님 오려면 파티 누구신지 들어오라고 명부 . 타클래스를 객체하고 메소드를 호출할거야 맨먼저 수입해야함)
같은 패키지에 있는 클래스는 자동으로 import 구문이 들어간다 손으로 코딩안해도.
동일한 패키지 안이여도 동일한 레벨은 코딩하지않아도 생략가능한데
동일한 패키지 안이여도 하위레벨의 소속클래스는 꼭 import를 써줘야 한다
( 같은폴더안에 그안의 폴더는 수입해야한다 
같은 폴더안에 같은레벨의 폴더는 수입하지 않아도 된다 )
수입만한다고 객체를 호출할수있는게 아니다.
객체화가능한지 살펴봐야하고 메소드호출이 가능한지 알아야한다
 
>자바에서 속성변수와 메소드를 호출하려면 3가지를 뚫어야한다(3단계보안)
1. 수입이 가능한가(수입가능여부)
2. 객체생성이 가능한가(객체생성가능여부)
3. 메소드를 호출 가능한가 (접근성때문에 안될 수 있다.)
 
package com.daum.erp;
import com.google.erp.Xxx;<--여기에 에러가 난다면
//1. 패키지명이 잘못됬거나 //2.Xxx클래스가 없거나//3.Xxx클래스 앞에 public접근가능자가 없거나
 
 
 >3. [public] [abstract/final] class 클래스명 {

1)public
>클래스 앞 public
수입 가능여부
 
>생성자 앞 public
객체생성가능여부
생성자 앞에 public이 붙으면 객체 생성가능여부
타클래스앞에서 객체 
 
2)final
>final 이 앞에있으면 후손클라스를 만들지 않겠다 (=상속금지)
자식이 해달라고 하는것.자식이 부모자식관계를 맺는것이다.
 
>final이 없으면 무슨뜻인가?
누가 와서 자식이 되어주세요 하면 해주는것 
싫어도 맺어주는것(자식이 들어와도 괜찮다.)
=> 자식이 필요없다**자식이 싫어
 
3)abstract (추상적인)
나 바디없는 메소드가 하나 이상있다. (바디={ 블럭 }) 
바디가 없으면 실행구문이 없다. 메소드 이름만 있다.
불분명하다 그래서 abstract 추상적이라고 본다
(객체생성의 목적은 실행구문 메소드 호출)
abstract가 붙은 놈은 객체생성이 안된다*
 
>바디없는 메소드를 왜갖고있냐?
니가 알아서 재정의해라 니가 알아서 메소드를 붙이고 재정의해서 갖다써라
자식이 빨리 들어왔으면 좋겟다는 의미
abstract가 붙어있으면 바디없는 메소드가 하나 이상.
=>자식을 빨리 갖고싶다.**빨리 자식이 들어왔으면 좋겠어
 
>abstract가 업으면 바디없는 메소드가 없다 객체화가 가능해요
 
>4. public/protected/default/private + [static] + [final] +

기본자료형/클래스명/인터페이스명 + 속성변수명 [=데이터];

 
>속성변수는 자동초기화가 안된다.
>데이터가 없으면 디폴트값을 자동으로 넣어준다.
 
>1) public

- 속성변수 앞에 public이 붙어있으면 다 호출이 가능해. 동일한클래스/동일한패키지/타패키지/ 전부 가능 
- 위 말이 맞다면 호출불 가능한 경우는 없을까?
- 아니다 수입(import)이 안되면 호출 불가능하다.
- 결론 = 수입을 허락하고 객체화까지 가능한 상태에서 누구든 호출가능하다.(=public)
- 객체생성이 되어야 가능하다.
>2) protected

속성변수나 메서드에만 붙다.
 
>3) default

- 동일한 패키지에있는 타클래스에서 객체생성이 성공하면 호출할 수 있는
>4) private  

- 동료만/같은 클래스 안에서만 가능 
>5) [static]

(객체끼리 공유할 수 있다. 객체 끼리 통신할 수 있다 속성변수 앞에 static을 붙이면 )
 
붙어있으면 객체 생성 없이도 호출 가능(단 수입이 된 상태, 접근지정자가 허락한 상태여야함)
static이 붙어있으면 a의 속성변수가 있다면 각 객체에 a가 모두의 a가 되는것이다.
 
staticdl 없다면 각 객체의 a의 속성변수가 따로이다.
static 이 없단 얘기는 무조건 객체생성하고 호출하라는 뜻
수입 통과 객체 통과한상태에서 접근지정자가 허락해야만 호출 가능.
 
static이 붙어있으면 
x클라스안에  속성변수 a가있다
3개를 객체화 했다 그안에도 a가 있다 자식관계니까
각 객체 안에 a가 서로 공유하고 인지 한다. a라는 속성변수는 각각 따로가 아니라 
공유를 할 수 있다. 업데이트할 수 있다. 객체간 통신을 할 수 있다.
단 객체가 2개이상 생성되어야한다
 
>5) [final]

속성변수 앞에 붙은 final은 갱신할 수 없다.  그데이터가 절대적인 데이터이기 때문에.
(ex)원주율,절대불변의 진리 데이터, 업무상 절대변하지않는 업무상 특징)
클래스 앞 final = 자식 안받겟다. 상속금지.
속성변수 앞 final = 갱신금지 
매소드앞 final =오버라이드 금지(아버지가 가지고있는 메서드를그대로가져다가 재정의 = 오버라이딩)
odverriding규칙이 있다.  매소드이름 , 리턴형도 똑같아야한다 접근지정자가 부모와 같거나 커야한다.
(지역변수 앞 final 가능) 지역변수는 휘발성 변수다
>6) 기본형 / 클래스명 / 인터페이스명

ex문제)
class Employee {
    int a1 = 123;
    double a2 = 123;
    Mmm a = 123;  //객체 메모리위치주소값이 들어가야하는데 123이들어감. int가 들어가야함.error
    Mmm a3 = new Mmm();
    String a4 = "초콜릿주세요";
    String a5 = '초';  //차로 바꿔야
    private int number = 123;//속성변수 앞에 프라이벳 붙을수있나 ㅇ 
    
    public int getNumber(){
         return 3.0;      //생성자가 아니다. 생성자는 리턴형이 없다. 생성자가 아닌이유는 클래스이름과 다름
    }//메소드를 호출하고난 후 돌려줄 데이터 = 리턴 자료형//리턴할게 없으면 void를 붙인다.
}
메소드안만아니면 속성변수다.
 
>5. public/protected/default/private  생성자명 ( [자료형 매개변수, ~] ) {

           실행구문;

  }

생성자의 호출이 안된다는 얘기는 객체화가 안된다는 뜻.
단한번의 호출에 대한 방법이 public/protect/default/private
생성자앞에 접근지정자가 붙으면
생성자 누군가가 객체화할때 public 타패키지 다 가능
 
private 붙어있으면 객체새성을 막아버림. 객체생성이 안됨. 클래스 만드는이유 객체 생성하려고.
뭔가 모순된다. 호출하는 방법. 객체생성이 불가능하지만 static을 이용하여 호출가능하다.
데이터를 보호하기위한. 매소드를 보호하기위해서는 보안성 높임
 
생성자에게 private붙어있으면 객체생성불가능 -> static
절대적인 개방형을 얘기한다. 객체생성하기 힘들지 나 다 static 붙여놨으니 다 갖다써.
생성자의 private 붙어있으면 오히려 개방성이다. 
static이 붙어있으면 객체 생성 없이도 호출가능하다.
생성자명은 클래스이름과 똑같다. 그앞에 자료형이 나올수가 없다.
리턴자료형이 없어야 한다.
 
>6. public/protected/default/private + [static] + [synchronized] +

[final / abstract] + 기본형/클래스명/인터페이스명/void + 메소드명( [자료형 매개변수, ~]){

      실행구문;

   }

>객체생성 없이 메소드를 생성할 수 있다.
 
>[final/ abstract]

>1) final
> 자식클래스가 아버지의 메소드를 그대로 가져가서 이름 그대로 가져다가 return형 그대로 가져다가
실행구문만 바꿔서 재정의 할 수 있다. (= overriding)
overriding을 금지시키는것이 final이다.
 
매소드앞 final =오버라이드 금지(아버지가 가지고있는 메서드를그대로가져다가 재정의 = 오버라이딩)
odverriding규칙이 있다.  매소드이름 , 리턴형도 똑같아야한다 접근지정자가 부모와 같거나 커야한다.
(지역변수 앞 final 가능) 지역변수는 휘발성 변수다
 
overriding이 있다는 얘기는 자식이 있다는얘기 (상속)
> 상속금지
 
>2) abstract
> abstract = 바디없는 메소드를 갖고 있다.
> 그 이유는 빨리 자식이 와서 내 메소드를 가져다가 쓰라는 소리.
> 자식에 대한 집착/ 자식에 대한 애착이 강함
> 상속관계
 
>기본형/클래스명/인터페이스명/void
>기본형
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
ex)
다음중 메서드 형식이 틀린걸/맞는걸 골라라
class Employee {
     public final int getNumber(){
          return 3
    } =>o
     public abstract final int getNumber(){
          return 3
    } =>x동시에 x final/abstract 반대된 개념이라.동시에 나올수 없다
     final public int getNumber(){
          return 3
    }=>x순서
     public abstract int getNumber();
     =>o abstract가 붙으면 객체화가 안됨, 바디가 없어야함
     public final int getNumber();
     =>x abstract가 없으면 바디가 있어야함.
}
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
ex1)
public int getNumber(){
          return 3
    }
=> 실행구문을 실행하고 데이터를 내놓을 때 int로 내준다(return 3은 3을 선물로 줄게)
3과 int 데이터타입이 같아야한다.
ex2)
public int getNumber(){
          return 3
 //      System.out.println("강아지"); <--실행하지않는다.
    } => o
public int getNumber(){
          return 3.0
    }  => x 리턴형과 메서드 왼쪽 자료형과 안 맞다. 
public double getNumber(){
          return 3
    } => o 암시적 형변환 자료형 우선순위에 앞서있기 때문에 오류 안난다.
public double getNumber(){
          return 3.0
    } => o
public double getNumber(){
          return ; //데이터가 없으면 메서드 중단하라 // 
    } => x // 더블형을 내놓기로 약속했는데 실행구문에 실수형데이터를 리턴하겠다는 문법이 없기 때문에 에러
 
public void getNumber(){
          return ; // 데이터가 안나와도 된다. 리턴도 안나와도 된다. 리턴하나는 나와도된다. 
                       // void가 안나오면 리턴이 나와야하고 데이터도 나와야한다.
}
->// 리턴은 반환하겠다는 말. 그다음 매서드 종료 //return이 나오면 그다음실행구문 실행 x
    // 리턴은 매서드의 암살자
    // 리턴의 두가지 뜻
    // 1. 리턴은 메서드 중단 2. 오른쪽에 데이터가 있으면 데이터 반환
    //return 오른쪽에 데이터가 없으면 메서드 중단하라 
 
    // 매소드 옆에 보이드가 붙으면 내부에 리턴할 데이터가 없다는 뜻.
    //  리턴이 나온다면 그옆에 데이터가 없어야하고. 데이터가 없다면 메서드를 중단하는 역할을 한다.
 
ex) 잘못된건 무엇인가?
class Employee{
     private int number = 123;
     if(number==123) {
     System.out.println("강아지");
     }                                  <-- 실행구문
     public Employee(){     <-- 매서드
     }
     public int getNumber(){
          return 3;
     }
}
=> if문 = 실행구문은 매서드안에 들어가야한다. 
=> 실행구문은 메서드안과 생성자 안에만 들어갈 수 있다.
 
>기본형/클래스명/인터페이스명/void
>클래스명
 
// 클래스를 객체화 했을 때 메위주(메시지 위치 주소값)
속성변수와 메소드를 호출해서 원하는걸 받을 수 있다. 
객체의 메위주를 리턴받는 놈이 장땡이다.
 
메소드 앞에 클래스명이 있으면 메위주를 선물받은거다. 
ex1)
public Xxx getNumber(){
     Xxx v = new Xxx();
     return v;
}  // error가 없다
 // 에러가 난다면 1. xxx 클래스가 없다 2. 클래스는 있지만 수입을 할 수 없다(없는데 객체화 하려고 한다.)
// 3. 객체 생성 안되게 막아버림 private이나 default로 막아버렸을 때.@@
 
ex2)
public Xxx getNumber(){
     Yyy v = new Yyy();
     return v;
} // Xxx, Yyy 클래스가 있다는 조건이 있다면 에러가 날까?
// Xxx와 Yyy가 부모자식관계라면 에러가 아니라면 Xxx가 부모클라스 Yyy가 자식클래스다.
// Yyy가 부모고 Xxx가 자식이면 에러.
자기가 객체화되면 부모거를 쓰면 허용을 한다. 
 
상속과 관련된 키워드 => final, abstract, 접근지정자(protected), 
 
 
